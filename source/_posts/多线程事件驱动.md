---
title: 多线程和事件驱动
date: 2019-08-02 09:21:40
tags: 杂谈
categories: 杂谈
---

设计一个高性能的服务器通常离不开多线程或者事件驱动/异步IO

#### 单线程、多线程以及事件驱动编程模型比较


 一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu
某种意义上说，服务端程序大多是事件驱动的，或者说是IO请求事件驱动的。这里比较的编程模型里的事件驱动是指事件处理部分是异步的，即不仅IO请求事件驱动，还有IO响应事件驱动，它的特点是当外部IO响应事件发生时使用回调机制来触发相应的处理。
事件驱动的一个非常有代表性的实现Node.js和redis，都是一个单进程（单线程）的服务（redis的数据落地或主从同步线程排除，其服务就是单线程的），事件处理都通过异步回调执行。第二节中单线程、多线程、事件驱动编程模型等类似比较中看起来事件驱动是单线程的，Node.js这一典型的事件驱动服务也是单线程的，导致许多人以为事件驱动只能是单线程的，不能充分利用多CPU多核资源。其实不然，Nginx也是一个典型的事件驱动服务，而Nginx是多进程的。从逻辑上划分后端服务，Nginx归为接入通信层（openresty这种nginx+lua实现业务逻辑的不在讨论范围），Node.js归为业务逻辑层。接入通信层的特点都是IO行为几乎不大消耗CPU是天然适合事件驱动的，也比较容易实现，而业务逻辑层的特点决定了事件驱动方式实现非常复杂，但这并意味着业务逻辑层的多线程事件驱动难以实现。


 在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。


 在多线程模型，每个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。另一个问题，操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。



 事件驱动的一个非常有代表性的实现Node.js和redis，都是一个单进程（单线程）
的服务（redis的数据落地或主从同步线程排除，其服务就是单线程的），事件处理都通过异步回调执行。第二节中单线程、多线程、事件驱动编程模型等类似比较中看起来事件驱动是单线程的，Node.js这一典型的事件驱动服务也是单线程的，导致许多人以为事件驱动只能是单线程的，不能充分利用多CPU多核资源。其实不然，Nginx也是一个典型的事件驱动服务，而Nginx是多进程的。从逻辑上划分后端服务，Nginx归为接入通信层（openresty这种nginx+lua实现业务逻辑的不在讨论范围），Node.js归为业务逻辑层。接入通信层的特点都是IO行为几乎不大消耗CPU是天然适合事件驱动的，也比较容易实现，而业务逻辑层的特点决定了事件驱动方式实现非常复杂，但这并意味着业务逻辑层的多线程事件驱动难以实现。


#### 事件驱动适用场景

对于IO密集型的业务，事件驱动比多线程同步的并发能力要高很多，可以说不是一个数量级的。而大部分互联网业务都属于IO密集型业务，因此事件驱动的适用场景非常广泛。程序中有许多高度独立的任务，在等待事件到来时，某些任务会阻塞，单个任务需要占用较少CPU资源。
